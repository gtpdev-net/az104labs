---
applyTo: '**/*.ps1,**/*.psm1'
description: 'Azure PowerShell scripting standards for GitHub Copilot'
---

# GitHub Copilot Instructions for Azure PowerShell

## Purpose
Ensure all Azure PowerShell code generated by GitHub Copilot adheres to Microsoft's latest best practices for cloud automation, resource management, and infrastructure deployment.

## Scope
These instructions apply to scripts that:
- Manage Azure resources (VMs, storage, networking)
- Configure identity and access (RBAC, Azure AD)
- Automate tasks via GitHub Actions
- Interact with Bicep deployments (handled separately via AVM)

## Module Usage
- Always use the **Az** module (`Az.Accounts`, `Az.Resources`, `Az.Compute`, etc.)
- Avoid legacy modules like `AzureRM`
- Use `Import-Module Az` only when necessary; for script headers, prefer the PowerShell `Requires` directive
- Validate module availability with `Get-Module -ListAvailable Az`

## Authentication
- Prefer `Connect-AzAccount` with service principal or managed identity for automation
- Avoid interactive login in scripts
- Use `Set-AzContext` to scope operations to a specific subscription or tenant

## Resource Management
- Use `New-AzResourceGroup`, `New-AzVM`, `New-AzStorageAccount`, etc. with full parameter sets
- Always validate resource existence before creation using `Get-AzResource` or `Test-AzResourceGroup`
- Use `-Force` only when necessary and document its impact

## Identity & Access
- Use `New-AzRoleAssignment` for RBAC
- Prefer object IDs over display names for users/groups
- Use `Get-AzADUser`, `Get-AzADGroup`, and `Get-AzADServicePrincipal` for identity queries

## Automation Patterns
- Scripts must be non-interactive and GitHub Actionsâ€“friendly
- Avoid `Read-Host`; use parameters and environment variables
- Use `Write-Verbose`, `Write-Warning`, and `Write-Error` for logging
- Implement `SupportsShouldProcess` and `ConfirmImpact` for destructive actions

## Error Handling
- Use `try/catch` blocks with `$PSCmdlet.ThrowTerminatingError()` for advanced functions
- Prefer `$PSCmdlet.WriteError()` over `Write-Error` for structured error reporting
- Avoid silent failures; always log or throw meaningful errors

## Output & Objects
- Return structured objects (`PSCustomObject`) for downstream processing
- Avoid `Write-Host` for data output
- Use `-PassThru` for action cmdlets that optionally return objects

## Naming Conventions
Follow PowerShell naming standards (see `powershell.instructions.md`):
- Cmdlets: `Verb-Noun` format with approved verbs
- Parameters: PascalCase, descriptive, singular
- Variables: camelCase (private), PascalCase (public)

## Script Structure
- Use advanced functions with `[CmdletBinding()]`
- Implement `Begin`, `Process`, `End` blocks for pipeline support
- Include comment-based help for all public functions

## Deployment Integration
- Use `New-AzDeployment` or `New-AzResourceGroupDeployment` to invoke Bicep templates
- Reference AVM modules via `azure.bicep-avm.instructions.md`
- Pass parameters via hashtables or parameter files

## GitHub Actions Compatibility
- Scripts must support execution in CI/CD pipelines
- Accept input via parameters or environment variables
- Avoid interactive prompts
- Use exit codes and structured output for job feedback

## Example Prompt
> Generate an Azure PowerShell script that creates a resource group, deploys a VM, assigns a role to a managed identity, and outputs the VM's public IP.

## Additional Resources
- Microsoft Learn Azure PowerShell documentation: https://learn.microsoft.com/en-us/powershell/azure